{
  "hash": "56a1f089c9325dbd65942d6a6be7038f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Simulating spatial network (Part 2)\"\nubtitle: \"Ok the better version\"\ndescription: \"How to simulate a semi-realistic spatial network, maybe in kind of a hackey way\"\nimage: \"pilgrim.jpg\"\ncategories: [\"Tutorial\", \"Code\"]\ntoc: true\ndraft: false\ncache: true\neditor_options: \n  chunk_output_type: console\nfreeze: auto\ntitle-block-banner: true\ndate: 7/31/2024\n---\n\n\n\n\n\n\n\nThis is a step by step guide for how we simulate the spatial network for `tritonet`.\n\n## 1. Sample the x and y coordinates for the patches.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(24601) # Set the seed number\nmax_distance <- 20 # Set the maximum limit of the xy plane.\n```\n:::\n\n\n\n\n\nWe use the `sample` function to randomly select both the x (longitude) and y (latitude) coordinates for each node. Using `dist`, we can then calculate the distance matrix for the pairwise distances between all nodes. The weight of the edges is then calculated using a negative exponential kernel.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxy <- seq(1, max_distance, length.out = 2000) ### All possible coordinates\nx_coord <- sample(xy, 100, replace = TRUE) # x-coordinate\ny_coord <- sample(xy, 100, replace = TRUE) # y-coordinate\nxy_coord <- cbind(x_coord, y_coord) # xy-coordinates combined\nNegExpDist <- as.matrix(exp(-dist(xy_coord))) # distance matrix with neg. exp kernel\n```\n:::\n\n\n\n\n\n## 2. Convert the distance matrix into an adjacency matrix\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAdj_graph <- graph_from_adjacency_matrix(NegExpDist,\n  mode = \"undirected\",\n  diag = FALSE,\n  weighted = TRUE\n)\n\n## Adding latitude and longitude\nV(Adj_graph)$Long <- xy_coord[, 1] # x-coordinates\nV(Adj_graph)$Lat <- xy_coord[, 2] # y-coordinates\n```\n:::\n\n\n\n\n\nWhen we plot the network, we can see that all nodes are connected to each other.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatialnetwork_files/figure-html/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n\n\n\n## 3. Reduce the edges\n\nWe are going to delete the majority of the edges. We assume a very low connectance (1%) and we back-calculate the number of edges that we must keep.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber_of_edges <- (0.01 * (100^2))\n```\n:::\n\n\n\n\n\nWe choose the top 100 highest-weight edges and delete all other edges.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### If the number of edges required for connectance is 100, then\n### choose the 100 likeliest (highest weight) edges.\ndeleted_edges_graph <- delete_edges(\n  Adj_graph,\n  which(E(Adj_graph)$weight < sort(E(Adj_graph)$weight,\n    decreasing = T\n  )[number_of_edges])\n)\n```\n:::\n\n\n\n\n\nThis is what it looks like now; we can see that there are components\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatialnetwork_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## 4. Choose the component with the greatest number of nodes\n\nUsing the function `decompose`, we can split the network into smaller networks.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndecomposed_components <- decompose(deleted_edges_graph)\n\n# Count the number of nodes for each component and then give me\n### the index for the largest component.\n\nbiggest_component_length <- which.max(lapply(\n  decomposed_components,\n  function(x) {\n    vcount(x)\n  }\n))\n\n### retrieve our network of interest\nnetwork_of_interest <- decomposed_components[[biggest_component_length]]\n```\n:::\n\n\n\n\n\nThis is the network of interest (the biggest component)\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatialnetwork_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## 5. Calculate the new connectance\n\nI create a function called `connectance_calculator` that calculates the connectance when given the number of nodes and edges.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### calculate the connectance by inputting the number of nodes and the number of\n### edges\n\nconnectance_calculator <- function(nodes, edges) {\n  return(edges / (nodes^2))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nconnectance_calculator(\n  vcount(network_of_interest),\n  ecount(network_of_interest)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.214876\n```\n\n\n:::\n:::\n\n\n\n\n\n## 6. Create an empty list to populate with igraph objects\n\nLet's create a list:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadj_list <- NULL # For the actual igraph\nadj_info_list <- NULL # For information about each igraph\n```\n:::\n\n\n\n\n\nLet's manually add the first one in.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadj_list[[1]] <- network_of_interest #put the igraph object in.\n\n\nadj_info_list[[1]] <- c( \n  num_nodes = vcount(network_of_interest),\n  num_edges = ecount(network_of_interest),\n  connectance = connectance_calculator(\n    vcount(network_of_interest),\n    ecount(network_of_interest)\n  )\n)\n```\n:::\n\n\n\n\n\n## 7. Add edges one by one\n\nFirst, we calculate the new distance matrix of the component network of interest:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the x-y coordinates\nxy_coord_interest <- cbind(\n  V(network_of_interest)$Long,\n  V(network_of_interest)$Lat\n)\n\n# Calculate new distance matrix\nDispMat_interest <- as.matrix(exp(-dist(xy_coord_interest)))\n```\n:::\n\n\n\n\n\nWe get the edge list of the network of interest.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedgelist_of_interest <- as_edgelist(network_of_interest, names = F)\n\n### The columns show the patches that are connected by an edge\nhead(edgelist_of_interest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    1    4\n[3,]    4    5\n[4,]    1    6\n[5,]    4    6\n[6,]    5    6\n```\n\n\n:::\n:::\n\n\n\n\n\nBy melting the distance matrix, we can then get a data.frame that shows the edge connections between the different nodes as well as the edge weights.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelted_edge_list <- melt(DispMat_interest)\n\n### patch1, patch2, and weight are the new column names\ncolnames(melted_edge_list) <- c(\"patch1\", \"patch2\", \"weight\")\n```\n:::\n\n\n\n\n\nWe want to remove rows from `melted_edge_list` that already exist in the `network_of_interest`. This is because we're interested in adding new edges that do not currently exist in the network.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_distance <- subset(\n  melted_edge_list,\n  !(paste0(\n    melted_edge_list$patch1, \"-\",\n    melted_edge_list$patch2\n  )\n  %in%\n    paste0(\n      edgelist_of_interest[, 1],\n      \"-\", edgelist_of_interest[, 2]\n    )\n  )\n)\n```\n:::\n\n\n\n\n\nLet us order the new data.frame by the edge weight:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_distance <- new_distance[order(new_distance$weight, decreasing = TRUE), ]\nhead(new_distance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   patch1 patch2    weight\n44     11      4 0.7933777\n76     10      7 0.7360045\n39      6      4 0.6963310\n7       7      1 0.5880216\n66     11      6 0.5739138\n20      9      2 0.5385340\n```\n\n\n:::\n:::\n\n\n\n\n\nWe're going to loop this, but just to how what is happening. We add an edge between patch1 and patch2 as well as its weight.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork_of_interest_added <- network_of_interest + edge(\n  c(\n    new_distance[1, \"patch1\"],\n    new_distance[1, \"patch2\"]\n  ),\n  weight = new_distance[1, \"weight\"]\n)\n```\n:::\n\n\n\n\n\nAgain, we're going to automate this, but we are going to add the information we need to the lists that we made earlier.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadj_list[[2]] <- network_of_interest_added\nadj_info_list[[2]] <- c(\n  num_nodes = vcount(network_of_interest_added),\n  num_edges = ecount(network_of_interest_added),\n  connectance = connectance_calculator(\n    vcount(network_of_interest_added),\n    ecount(network_of_interest_added)\n  )\n)\n```\n:::\n\n\n\n\n\n## 8. Loop through.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq(2, nrow(new_distance))) {\n  network_of_interest_added <- network_of_interest_added + edge(\n    c(\n      new_distance[i, \"patch1\"],\n      new_distance[i, \"patch2\"]\n    ),\n    weight = new_distance[i, \"weight\"]\n  )\n\n\n  adj_list[[i + 1]] <- network_of_interest_added\n  adj_info_list[[i + 1]] <- c(\n    num_nodes = vcount(network_of_interest_added),\n    num_edges = ecount(network_of_interest_added),\n    connectance = connectance_calculator(\n      vcount(network_of_interest_added),\n      ecount(network_of_interest_added)\n    )\n  )\n}\n```\n:::\n\n\n\n\n\n## 9. Check that there is a positive relationship with edge number and connectance\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadj_info_df <- data.frame(do.call(rbind, adj_info_list))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(adj_info_df, aes(x = num_edges, y = connectance)) +\n  geom_point() +\n  ylab(\"Connectance\") +\n  xlab(\"Number of edges\") +\n  theme_classic() +\n  theme(\n    axis.text = element_text(size = 14),\n    axis.title = element_text(size = 15)\n  )\n```\n\n::: {.cell-output-display}\n![](spatialnetwork_files/figure-html/unnamed-chunk-24-1.png){width=480}\n:::\n:::\n\n\n\n\n\nWe can see that by increasing the number of edges, we also increase the connectance.\n\n## 10. Creating the full function\n\nGoing to be a huge function so break it into much smaller sub-functions.\n\nThe function `simulate_xy_coordinates` corresponds to Step 1 (Sample x-y coordinates for the patches). The output should be a list with the first element being the data.frame holding the x and y coordinates of the nodes and the second element being the distance matrix.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_xy_coordinates <- function(seed = 24601, max_distance) {\n  set.seed(seed)\n  xy <- seq(1, max_distance, length.out = 2000) ### List of all possible coordinates\n  x_coord <- sample(xy, 100, replace = TRUE) # x-coordinate\n  y_coord <- sample(xy, 100, replace = TRUE) # y-coordinate\n  xy_coord <- cbind(x_coord, y_coord) # xy-coordinates combined\n  NegExpDist <- as.matrix(exp(-dist(xy_coord))) # distance matrice with kernel\n\n  return(list(xy_coord, NegExpDist))\n}\n```\n:::\n\n\n\n\n\nThe function `retrieve_biggest_component` corresponds to Step 2 (Convert the distance matrix into an adjacency matrix), Step 3 (Reduce the edges), and Step 4 (Choose the components with the greatest number of nodes). The input takes the list element from `simulate_xy_coordinate` and returns the network of interest.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nretrieve_biggest_component <- function(list) {\n  Adj_graph <- graph_from_adjacency_matrix(list[[2]],\n    mode = \"undirected\",\n    diag = FALSE,\n    weighted = TRUE\n  )\n\n  ## Adding latitude and longitude\n  V(Adj_graph)$Long <- list[[1]][, 1] # x-coordinates\n  V(Adj_graph)$Lat <- list[[1]][, 2] # y-coordinates\n\n  number_of_edges <- (0.01 * (100^2))\n\n  deleted_edges_graph <- delete_edges(\n    Adj_graph,\n    which(E(Adj_graph)$weight < sort(E(Adj_graph)$weight,\n      decreasing = T\n    )[number_of_edges])\n  )\n\n\n  decomposed_components <- decompose(deleted_edges_graph)\n\n  # Count the number of nodes for each componenent and then give me\n  ### the index for the largest.\n  biggest_component_length <- which.max(lapply(\n    decomposed_components,\n    function(x) {\n      vcount(x)\n    }\n  ))\n\n  ### retrieve our network of interest\n  network_of_interest <- decomposed_components[[biggest_component_length]]\n\n  return(network_of_interest)\n}\n```\n:::\n\n\n\n\n\nThe function `recalculate_distance_matrix` correspond to the first half of step 5 (Add edges one by one). You input the network of interest and should return a data.frame that has all the possible edges (that are not in the current network) sorted in decreasing order of edge weight.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecalculate_distance_matrix <- function(network) {\n  # Get the x-y coordinates\n  xy_coord_interest <- cbind(\n    V(network)$Long,\n    V(network)$Lat\n  )\n\n  # Calculate new distance matrices\n  DispMat_interest <- as.matrix(exp(-dist(xy_coord_interest)))\n\n  edgelist_of_interest <- as_edgelist(network, names = F)\n\n  melted_edge_list <- melt(DispMat_interest)\n\n  colnames(melted_edge_list) <- c(\"patch1\", \"patch2\", \"weight\")\n\n\n  new_distance <- subset(\n    melted_edge_list,\n    !(paste0(\n      melted_edge_list$patch1, \"-\",\n      melted_edge_list$patch2\n    )\n    %in%\n      paste0(\n        edgelist_of_interest[, 1],\n        \"-\", edgelist_of_interest[, 2]\n      )\n    )\n  )\n\n  new_distance_df <- new_distance[order(new_distance$weight, decreasing = TRUE), ]\n\n  return(new_distance_df)\n}\n```\n:::\n\n\n\n\n\nThe full function thus looks like this:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_spatial_network <- function(seed, max_distance) {\n        \n  list_xy_coord <- simulate_xy_coordinates(seed, max_distance)\n  network_interest <- retrieve_biggest_component(list_xy_coord)\n  possible_edges_df <- recalculate_distance_matrix(network_interest)\n  adj_list <- NULL\n  adj_info_list <- NULL\n\n  ### Manually add the first network in\n\n  adj_list[[1]] <- network_interest\n  adj_info_list[[1]] <- c(\n    num_nodes = vcount(network_interest),\n    num_edges = ecount(network_interest),\n    connectance = connectance_calculator(\n      vcount(network_interest),\n      ecount(network_interest)\n    )\n  )\n\n  ### For loop time\n  for (new_edge in seq(1, nrow(possible_edges_df))) {\n    network_interest <- network_interest + edge(c(new_distance[new_edge, \"patch1\"], new_distance[new_edge, \"patch2\"]),\n      weight = new_distance[new_edge, \"weight\"]\n    )\n\n    adj_list[[new_edge + 1]] <- network_interest\n    adj_info_list[[new_edge + 1]] <- c(\n      num_nodes = vcount(network_interest),\n      num_edges = ecount(network_interest),\n      connectance = connectance_calculator(\n        vcount(network_interest),\n        ecount(network_interest)\n      )\n    )\n  }\n  return(list(adj_list, do.call(rbind, adj_info_list)))\n}\n```\n:::\n\n\n\n\n\n## 11. Testing the full function\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulated_list <- simulate_spatial_network (24601, 20)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(simulated_list[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      num_nodes num_edges connectance\n [1,]        11        26   0.2148760\n [2,]        11        27   0.2231405\n [3,]        11        28   0.2314050\n [4,]        11        29   0.2396694\n [5,]        11        30   0.2479339\n [6,]        11        31   0.2561983\n [7,]        11        32   0.2644628\n [8,]        11        33   0.2727273\n [9,]        11        34   0.2809917\n[10,]        11        35   0.2892562\n[11,]        11        36   0.2975207\n[12,]        11        37   0.3057851\n[13,]        11        38   0.3140496\n[14,]        11        39   0.3223140\n[15,]        11        40   0.3305785\n[16,]        11        41   0.3388430\n[17,]        11        42   0.3471074\n[18,]        11        43   0.3553719\n[19,]        11        44   0.3636364\n[20,]        11        45   0.3719008\n[21,]        11        46   0.3801653\n[22,]        11        47   0.3884298\n[23,]        11        48   0.3966942\n[24,]        11        49   0.4049587\n[25,]        11        50   0.4132231\n[26,]        11        51   0.4214876\n[27,]        11        52   0.4297521\n[28,]        11        53   0.4380165\n[29,]        11        54   0.4462810\n[30,]        11        55   0.4545455\n[31,]        11        56   0.4628099\n[32,]        11        57   0.4710744\n[33,]        11        58   0.4793388\n[34,]        11        59   0.4876033\n[35,]        11        60   0.4958678\n[36,]        11        61   0.5041322\n[37,]        11        62   0.5123967\n[38,]        11        63   0.5206612\n[39,]        11        64   0.5289256\n[40,]        11        65   0.5371901\n[41,]        11        66   0.5454545\n[42,]        11        67   0.5537190\n[43,]        11        68   0.5619835\n[44,]        11        69   0.5702479\n[45,]        11        70   0.5785124\n[46,]        11        71   0.5867769\n[47,]        11        72   0.5950413\n[48,]        11        73   0.6033058\n[49,]        11        74   0.6115702\n[50,]        11        75   0.6198347\n[51,]        11        76   0.6280992\n[52,]        11        77   0.6363636\n[53,]        11        78   0.6446281\n[54,]        11        79   0.6528926\n[55,]        11        80   0.6611570\n[56,]        11        81   0.6694215\n[57,]        11        82   0.6776860\n[58,]        11        83   0.6859504\n[59,]        11        84   0.6942149\n[60,]        11        85   0.7024793\n[61,]        11        86   0.7107438\n[62,]        11        87   0.7190083\n[63,]        11        88   0.7272727\n[64,]        11        89   0.7355372\n[65,]        11        90   0.7438017\n[66,]        11        91   0.7520661\n[67,]        11        92   0.7603306\n[68,]        11        93   0.7685950\n[69,]        11        94   0.7768595\n[70,]        11        95   0.7851240\n[71,]        11        96   0.7933884\n[72,]        11        97   0.8016529\n[73,]        11        98   0.8099174\n[74,]        11        99   0.8181818\n[75,]        11       100   0.8264463\n[76,]        11       101   0.8347107\n[77,]        11       102   0.8429752\n[78,]        11       103   0.8512397\n[79,]        11       104   0.8595041\n[80,]        11       105   0.8677686\n[81,]        11       106   0.8760331\n[82,]        11       107   0.8842975\n[83,]        11       108   0.8925620\n[84,]        11       109   0.9008264\n[85,]        11       110   0.9090909\n[86,]        11       111   0.9173554\n[87,]        11       112   0.9256198\n[88,]        11       113   0.9338843\n[89,]        11       114   0.9421488\n[90,]        11       115   0.9504132\n[91,]        11       116   0.9586777\n[92,]        11       117   0.9669421\n[93,]        11       118   0.9752066\n[94,]        11       119   0.9834711\n[95,]        11       120   0.9917355\n[96,]        11       121   1.0000000\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}