{
  "hash": "b7025c655de0da39d7a1cc8575bdaee0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Simulating a scale-free network\"\nsubtitle: \"Varying connectance...\"\ndescription: \"One possible (possibly bad) way of modeling a spatial network that is also scale-free\"\nimage: \"euler.jpg\"\ncategories: [\"Code\",\"Tutorial\"]\ntoc: true\ndraft: false\ncache: true\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(ggplot2)\nlibrary(reshape2)\nset.seed(24601)\n```\n:::\n\n\n\n## An introduction\n\nNote: I have done a much better way (but I have left this up as a historical relic)\n\nThe goal is to create a spatial network that is scale-free with the user having the ability to vary the connectance. Assuming that $n$ is the number of patches and $l$ is the number of edges,the connectance ($C$) is then: $\\frac{l}{n^2}$.\n\n## Size of the network and connectance\n\nThe number of patches then determines the minimum and maximum number of edges possible. In an undirected graph, the minimum number of edges we can have is $n-1$ . For the maximum number of edges: $n \\frac{(n-1)}{2}$. With both the number of patches and edges, we can then calculate the minimum and maximum value of connectance.\n\nFor example, if we have 20 patches ($n = 20$):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = 20\nmin_edge = n - 1 # 19\nmax_edge = n * (n-1)/2 # 190 \n```\n:::\n\n\n\nWith the minimum and maximum number of edges being 19 and 190 respectfully, the minimum and maximum connectances are:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(min_edge/(n^2), max_edge/(n^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0475 0.4750\n```\n\n\n:::\n:::\n\n\n\nHere is a short function to calculate connectivity when given a network:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n###Put an igraph network \ncalculate_connectivity <- function(network){\n  \n  nodes =  vcount(network) #Code the number of vertex/patch/node\n  edges = ecount(network) #Count the number of edges\n  return(edges/(nodes^2)) #Return the connectance\n  \n}\n```\n:::\n\n\n\nTherefore, with a given number of patches, I can calculate the number of edges needed to get the specific value of connectance.\n\n## Simulating creating spatial coordinates\n\nFirst, we create a spatial network. We sample the coordinates from a uniform distribution with a maximum distance:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx.coordinates <- runif(n,0,10)\ny.coordinates <- runif(n,0,10)\npoints <- cbind(x.coordinates,y.coordinates)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](simulatenetwork_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nI'm, however, more interested in getting the distances between points.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance_matrix <- as.matrix(dist(points))\n```\n:::\n\n\n\nThis gives us a matrix that has the distances between points.\n\n## For each connectance value, calculate the number of edges\n\nThis is a function to calculate the number of edges. I want to get connectance values of 0.05, 0.10, 0.20, 0.30, and 0.40. Then the total number of edges needed based on the patch number is: $C n^2$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_edge <- function(n){\n  connectance  = c(0.05,0.10,0.20,0.30,0.40) #good ranges?\n  \n   return(connectance * n^2)\n}\n```\n:::\n\n\n\nTherefore, if I want to create a network with this connectance value, here are the number of edges that I need:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind.data.frame(connectance = c(0.05,0.10, 0.20, 0.30,0.40),\n                 edges = calculate_edge(20))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  connectance edges\n1        0.05    20\n2        0.10    40\n3        0.20    80\n4        0.30   120\n5        0.40   160\n```\n\n\n:::\n:::\n\n\n\n## Using Barabási–Albert for preferential attachment\n\nI'm assuming that the spatial network is scale-free (Need to find more references to verify this). I don't think this is a bad assumption. In igraph, to create a scale-free network with preferential attachment, we uses sample_pa. In this stochastic algorithm, you add new nodes and edges with each time step.\n\nThe only way to manipulate the total number of edges you want is by using the \"out_seq\" argment which states: Numeric vector giving the number of edges to add in each time step. Its first element is ignored as no edges are added in the first time step\". Therefore, you can ensure that you have the right number of edges added by summing the vector.\n\nHere, is a function that lets me generate a number of edges to be added with each time step (I took code from this stackoverflow post) (Source: [Generate Random network models with specified number of edges](https://stackoverflow.com/questions/37178286/generate-random-network-models-with-specified-number-of-edges-in-r)).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenOutSeq <- function(n, m) {\n  n <- n-1 # Shift it along\n  rem <- m %% n\n  c(0, rep(m%/%n + 1, rem), rep(m%/%n, n - rem))\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### The out_seq to be put into the network.\nedges_list <-  lapply(calculate_edge (20),  function(x) genOutSeq(n,x))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadjacency_matrix_list <- list()\n\nfor (k in seq(1,length(edges_list))){\n\nnet <- sample_pa(\n  n, #Number of patches\n  power = 1,\n  out.seq = edges_list[[k]], #This is the vector list\n  zero.appeal = 1,\n  directed = FALSE, #undirected\n  algorithm = c(\"psumtree\"), #Prevents multiedges\n  start.graph = NULL)\n\n\n###It is possible that I don't have the right number of edges\n###so I must randomly add edges if there are some missing\nnMulti <- sum(edges_list[[k]]) - gsize(net)\n\n\n### We basically run this until we have the correct number of edges AND\n### there are no mutliedges\nwhile(is_simple(net) == FALSE){\nfor (i in 1:nMulti) {\n  vPair <- sample(1:n, size = 2)\n  net <- add_edges(net, vPair)\n  \n  net <- simplify(net,\n  remove.multiple = TRUE,\n  remove.loops = TRUE)\n}\n}\n\n###Convert graph to adjacency matrix\nadj_matrix <- as_adjacency_matrix(\n  net,\n  type = c(\"both\"),\nsparse = \"false\")\n\n### Save adjacency matrix ot a list\nadjacency_matrix_list[[k]] <- as.matrix(adj_matrix)\n}\n```\n:::\n\n\n\n## Combining the spatial distances and the scale-free network\n\nI realized that I should simulate the same network with various distances between the patches.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n###This generates the distance matrices between patches\ngenerate_distance_matrix <- function(n, max_distance){\n  x.coordinates <- runif(n,0,max_distance)\n  y.coordinates <- runif(n,0,max_distance)\n  points <- cbind(x.coordinates,y.coordinates)\n  distance_matrix <- as.matrix(dist(points))\n  \n  return(distance_matrix)\n  \n}\ngenerate_distance_matrix(20,16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           1         2         3         4         5          6         7\n1   0.000000  5.157415 15.193534  6.956727 10.595116 11.0874552 11.626523\n2   5.157415  0.000000 12.584992  2.113439  7.126970 13.1673740  9.468252\n3  15.193534 12.584992  0.000000 10.849847  5.601309 11.9520194  3.604385\n4   6.956727  2.113439 10.849847  0.000000  5.273883 13.2341047  8.008133\n5  10.595116  7.126970  5.601309  5.273883  0.000000 11.7723962  3.387007\n6  11.087455 13.167374 11.952019 13.234105 11.772396  0.0000000  9.433731\n7  11.626523  9.468252  3.604385  8.008133  3.387007  9.4337309  0.000000\n8   4.873067  2.974354 10.609897  3.173989  5.727345 10.2786557  7.181685\n9  14.337942 10.288828  5.060660  8.208842  3.892680 14.9467973  5.563506\n10  9.978614  4.826225 11.473110  3.284642  6.138704 16.1859300  9.464290\n11  2.330038  4.518944 12.907996  5.762383  8.536265  9.4506963  9.325471\n12  7.855760  5.708047  7.382344  4.647664  3.186196  9.2709702  3.922495\n13  5.868926  2.873714  9.966747  2.343386  4.823247 10.8959945  6.683709\n14 13.941346 14.882039  9.894034 14.411544 11.511777  3.8356737  8.440559\n15 11.518690 13.523889 11.903111 13.544006 11.931739  0.4457247  9.495183\n16 12.320441 10.815616  3.780814  9.545150  5.198992  8.2663361  1.822419\n17 10.769585  8.458042  4.425673  6.997295  2.596253  9.5504748  1.014959\n18 13.825584 15.428669 11.728347 15.210645 12.855849  2.8619062  9.980735\n19  6.031332  4.818469  9.162611  4.490833  4.960311  8.7478925  5.609609\n20 10.288681 11.010526  8.654084 10.636661  8.434724  3.4550483  5.979122\n           8         9        10        11        12        13        14\n1   4.873067 14.337942  9.978614  2.330038  7.855760  5.868926 13.941346\n2   2.974354 10.288828  4.826225  4.518944  5.708047  2.873714 14.882039\n3  10.609897  5.060660 11.473110 12.907996  7.382344  9.966747  9.894034\n4   3.173989  8.208842  3.284642  5.762383  4.647664  2.343386 14.411544\n5   5.727345  3.892680  6.138704  8.536265  3.186196  4.823247 11.511777\n6  10.278656 14.946797 16.185930  9.450696  9.270970 10.895994  3.835674\n7   7.181685  5.563506  9.464290  9.325471  3.922495  6.683709  8.440559\n8   0.000000  9.475056  6.432780  2.983490  3.259538  1.101142 11.909801\n9   9.475056  0.000000  7.503353 12.369914  7.064457  8.475221 13.900773\n10  6.432780  7.503353  0.000000  9.016932  7.072227  5.493291 16.923081\n11  2.983490 12.369914  9.016932  0.000000  5.631318  4.078112 11.958847\n12  3.259538  7.064457  7.072227  5.631318  0.000000  2.843700  9.879585\n13  1.101142  8.475221  5.493291  4.078112  2.843700  0.000000 12.214657\n14 11.909801 13.900773 16.923081 11.958847  9.879585 12.214657  0.000000\n15 10.619311 15.032079 16.462386  9.858851  9.506757 11.210803  3.471485\n16  8.265301  7.118348 11.224512  9.990403  5.113260  7.956910  6.782439\n17  6.227417  5.421074  8.549443  8.492820  2.973592  5.688215  8.954794\n18 12.468831 15.518238 17.932983 12.048341 10.864687 12.926205  1.934995\n19  1.896866  8.852179  7.497992  3.768494  1.878649  2.170724 10.088460\n20  8.036498 11.497423 13.321285  8.190764  6.254737  8.388567  3.880907\n           15        16        17        18        19        20\n1  11.5186899 12.320441 10.769585 13.825584  6.031332 10.288681\n2  13.5238889 10.815616  8.458042 15.428669  4.818469 11.010526\n3  11.9031106  3.780814  4.425673 11.728347  9.162611  8.654084\n4  13.5440064  9.545150  6.997295 15.210645  4.490833 10.636661\n5  11.9317388  5.198992  2.596253 12.855849  4.960311  8.434724\n6   0.4457247  8.266336  9.550475  2.861906  8.747892  3.455048\n7   9.4951835  1.822419  1.014959  9.980735  5.609609  5.979122\n8  10.6193112  8.265301  6.227417 12.468831  1.896866  8.036498\n9  15.0320794  7.118348  5.421074 15.518238  8.852179 11.497423\n10 16.4623864 11.224512  8.549443 17.932983  7.497992 13.321285\n11  9.8588514  9.990403  8.492820 12.048341  3.768494  8.190764\n12  9.5067573  5.113260  2.973592 10.864687  1.878649  6.254737\n13 11.2108027  7.956910  5.688215 12.926205  2.170724  8.388567\n14  3.4714848  6.782439  8.954794  1.934995 10.088460  3.880907\n15  0.0000000  8.258882  9.658070  2.417472  9.053737  3.539507\n16  8.2588825  0.000000  2.675237  8.435509  6.495927  4.897432\n17  9.6580700  2.675237  0.000000 10.374968  4.738255  6.119064\n18  2.4174721  8.435509 10.374968  0.000000 10.757652  4.611757\n19  9.0537368  6.495927  4.738255 10.757652  0.000000  6.238836\n20  3.5395065  4.897432  6.119064  4.611757  6.238836  0.000000\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Generate 5 distance matrix - ideally i should have a large number of simulated distance matrices (n = 1000)\ndistance_matrices<- replicate(5,generate_distance_matrix(20,16),simplify=FALSE)\n```\n:::\n\n\n\nThis code is to basically take the adjacency matrix that we created earlier with varying connectance and multiply it by the distance matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatial_scale_free_network <- NULL\n\nfor (i in seq(1, length(adjacency_matrix_list))) {\n  adjacency_matrix_list_Interest <- adjacency_matrix_list[[i]]\n\n  spatial_scale_free_network[[i]] <- lapply(distance_matrices, function(x) x * adjacency_matrix_list_Interest)\n}\n```\n:::\n\n\n\nLet's plot it out. Here we are looking at the adjaceny matrix associated with low connectance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_low_connectance<-   lapply(\nspatial_scale_free_network[[1]],function(x)\ngraph_from_adjacency_matrix(x, mode = \n                            \"undirected\", \n                            weighted= \"TRUE\"))\n```\n:::\n\n\n\nOk, you should be able to see different distances between patches.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(3,2))\nfor (i in seq(1,5)){\n  plot(graph_low_connectance[[i]],layout=layout.auto)\n}\n```\n\n::: {.cell-output-display}\n![](simulatenetwork_files/figure-html/unnamed-chunk-17-1.png){width=960}\n:::\n:::\n\n\n\nHere is a high connectance one:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_high_connectance<-   lapply(\nspatial_scale_free_network[[5]],function(x)\ngraph_from_adjacency_matrix(x, mode = \n                            \"undirected\", weighted= \"TRUE\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(3,2))\n\nfor (i in seq(1,5)){\n  plot(graph_high_connectance[[i]],layout=layout.auto)\n}\n```\n\n::: {.cell-output-display}\n![](simulatenetwork_files/figure-html/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}